const buffer = require('buffer');
const assert = require('assert').strict;
const path = require('path');
const { fork } = require('child_process');

const fsPromise = require('../src/fsPromise');
const Utils = require('../src/utils');
const FakeFileGenerator = require('../index');

// the max integer value that Buffer.alloc(size) supports
const bufferMaxLength = buffer.constants.MAX_LENGTH;

const fileTxt = 'test.txt';
const fileNotTyped = 'test.png';

const filesPath = path.join(__dirname, '..', 'autogenerated-files');

describe('megabytes to bytes', () => {
    test('convert megabytes to bytes', () => {
        const megabytes = 1;
        const expectedResults = 1000000;

        const resultBytes = Utils.megabyteToByte(megabytes);
        assert.strictEqual(resultBytes, expectedResults);
    })
})

describe('handle errors', () => {
    test('write file with wrong filePath parameter', async () => {
        const fileName = fileNotTyped;
        const notExistsFolder = 'not-exists'
        const filePath = path.join(filesPath, notExistsFolder, fileName);

        const size = bufferMaxLength + Utils.megabyteToByte(1);

        try {
            await FakeFileGenerator.makeFile(filePath, size);
        } catch (err) {
            assert.strictEqual(err.code,'ENOENT');
        }
    })
});

describe('writeFile not typed', () => {
    test('generate file not typed at specific size, bigger than buffer.constants.MAX_LENGTH', () => {
        const filePath = path.join(filesPath, fileNotTyped);

        const size = bufferMaxLength + Utils.megabyteToByte(50);

        return Promise.resolve()
            .then(makeFile)
            .then(checkGeneratedFile)
            .catch((err) => {
                throw err;
            })

        function makeFile() {
            return FakeFileGenerator.makeFile(filePath, size);
        }
        async function checkGeneratedFile() {
            const fileToCheckStats = await fsPromise.stat(filePath);
            assert.strictEqual(fileToCheckStats.size, size);
        }
    }, 100000)
    test('generate file not typed at specific size, smaller than buffer.constants.MAX_LENGTH', () => {
        const filePath = path.join(filesPath, fileNotTyped);

        const size = bufferMaxLength - Utils.megabyteToByte(5);

        return Promise.resolve()
            .then(makeFile)
            .then(checkGeneratedFile)
            .catch((err) => {
                throw err;
            })

        function makeFile() {
            return FakeFileGenerator.makeFile(filePath, size);
        }
        async function checkGeneratedFile() {
            const fileToCheckStats = await fsPromise.stat(filePath);
            assert.strictEqual(fileToCheckStats.size, size);
        }
    }, 100000)
    test('generate file not typed at specific size, smaller highWaterMark', () => {
        const filePath = path.join(filesPath, fileNotTyped);

        const defaultHighWaterMarkSize = 16384;
        const size = defaultHighWaterMarkSize - 500;

        return Promise.resolve()
            .then(makeFile)
            .then(checkGeneratedFile)
            .catch((err) => {
                throw err;
            })

        function makeFile() {
            return FakeFileGenerator.makeFile(filePath, size);
        }
        async function checkGeneratedFile() {
            const fileToCheckStats = await fsPromise.stat(filePath);
            assert.strictEqual(fileToCheckStats.size, size);
        }
    })
})

describe('writeFile txt', () => {
    test('generate file txt, (size less than watermark)', () => {

        const expectedFileContent = 'START-->abcdefghilmnopqr<--END';
        const filePath = path.join(filesPath, fileTxt);

        const size = 30;

        return Promise.resolve()
            .then(makeFile)
            .then(checkGeneratedFile)
            .catch((err) => {
                throw err;
            })

        function makeFile() {
            const options = {
                type: 'txt',
            }
            return FakeFileGenerator.makeFile(filePath, size, options);
        }
        async function checkGeneratedFile() {
            const fileToCheckStats = await fsPromise.stat(filePath);
            assert.strictEqual(fileToCheckStats.size, size);
            const fileContent = await fsPromise.readFile(filePath);
            assert.strictEqual(fileContent.toString(), expectedFileContent);
        }
    }, 100000)
    test('generate file txt, (size less than START--><--END)', () => {

        const expectedFileContent = 'START-->abcd';
        const filePath = path.join(filesPath, fileTxt);

        const size = 12;

        return Promise.resolve()
            .then(makeFile)
            .then(checkGeneratedFile)
            .catch((err) => {
                throw err;
            })

        function makeFile() {
            const options = {
                type: 'txt',
            }
            return FakeFileGenerator.makeFile(filePath, size, options);
        }
        async function checkGeneratedFile() {
            const fileToCheckStats = await fsPromise.stat(filePath);
            assert.strictEqual(fileToCheckStats.size, size);
            const fileContent = await fsPromise.readFile(filePath);
            assert.strictEqual(fileContent.toString(), expectedFileContent);
        }
    }, 100000)
    test('generate file txt, (size less than START-->)', () => {

        const expectedFileContent = 'STAR';
        const filePath = path.join(filesPath, fileTxt);

        const size = 4;

        return Promise.resolve()
            .then(makeFile)
            .then(checkGeneratedFile)
            .catch((err) => {
                throw err;
            })

        function makeFile() {
            const options = {
                type: 'txt',
            }
            return FakeFileGenerator.makeFile(filePath, size, options);
        }
        async function checkGeneratedFile() {
            const fileToCheckStats = await fsPromise.stat(filePath);
            assert.strictEqual(fileToCheckStats.size, size);
            const fileContent = await fsPromise.readFile(filePath);
            assert.strictEqual(fileContent.toString(), expectedFileContent);
        }
    }, 100000)
    test('generate file txt, (size more than watermark)', () => {

        const expectedEndFileContent = '<--END';
        const watermarkSize = 16384;
        const filePath = path.join(filesPath, fileTxt);

        const size = watermarkSize + 50;

        return Promise.resolve()
            .then(makeFile)
            .then(checkGeneratedFile)
            .catch((err) => {
                throw err;
            })

        function makeFile() {
            const options = {
                type: 'txt',
            }
            return FakeFileGenerator.makeFile(filePath, size, options);
        }
        async function checkGeneratedFile() {
            const fileToCheckStats = await fsPromise.stat(filePath);
            assert.strictEqual(fileToCheckStats.size, size);
            const fileContent = await fsPromise.readFile(filePath);
            const fileContentToCheck = fileContent
                .toString()
                .substr(fileContent.length - expectedEndFileContent.length,fileContent.length-1);
            assert.strictEqual(fileContentToCheck, expectedEndFileContent);
        }
    }, 100000)
    test('generate file txt, (size double than watermark)', () => {

        const expectedEndFileContent = '<--END';
        const watermarkSize = 16384 * 2;
        const filePath = path.join(filesPath, fileTxt);

        const size = watermarkSize;

        return Promise.resolve()
            .then(makeFile)
            .then(checkGeneratedFile)
            .catch((err) => {
                throw err;
            })

        function makeFile() {
            const options = {
                type: 'txt',
            }
            return FakeFileGenerator.makeFile(filePath, size, options);
        }
        async function checkGeneratedFile() {
            const fileToCheckStats = await fsPromise.stat(filePath);
            assert.strictEqual(fileToCheckStats.size, size);
            const fileContent = await fsPromise.readFile(filePath);
            const fileContentToCheck = fileContent
                .toString()
                .substr(fileContent.length - expectedEndFileContent.length,fileContent.length-1);
            assert.strictEqual(fileContentToCheck, expectedEndFileContent);
        }
    }, 100000)
    test('generate file txt, (size double than watermark plus 5)', () => {

        const expectedEndFileContent = '<--END';
        const watermarkSize = (16384 * 2) +5;
        const filePath = path.join(filesPath, fileTxt);

        const size = watermarkSize;

        return Promise.resolve()
            .then(makeFile)
            .then(checkGeneratedFile)
            .catch((err) => {
                throw err;
            })

        function makeFile() {
            const options = {
                type: 'txt',
            }
            return FakeFileGenerator.makeFile(filePath, size, options);
        }
        async function checkGeneratedFile() {
            const fileToCheckStats = await fsPromise.stat(filePath);
            assert.strictEqual(fileToCheckStats.size, size);
            const fileContent = await fsPromise.readFile(filePath);
            const fileContentToCheck = fileContent
                .toString()
                .substr(fileContent.length - expectedEndFileContent.length,fileContent.length-1);
            assert.strictEqual(fileContentToCheck, expectedEndFileContent);
        }
    }, 100000)
});

describe('cli mode', () => {
    test('generate not typed file', async () => {

        const notExpectedEndFileContent = '<--END';
        const indexFilePath = path.join(process.cwd(), 'index.js');

        const filePath = path.join(filesPath, fileNotTyped);

        const size = Utils.megabyteToByte(1);

        const forked = fork(indexFilePath, ['--fileName', filePath, '--size', size], {
            env: { DEBUG: 'fake-file-generator:*' }
        });

        await new Promise((resolve, reject) => {
            forked.on('close', resolve)
            forked.on('error', reject)
            forked.on('exit', code => {
                if (code !== 0) reject();
            })
        })

        const fileToCheckStats = await fsPromise.stat(filePath);
        assert.strictEqual(fileToCheckStats.size, size);
        const fileContent = await fsPromise.readFile(filePath);
        assert.strictEqual(fileContent.toString().includes(notExpectedEndFileContent), false);

    }, 100000)
    test('generate txt file', async () => {

        const expectedEndFileContent = '<--END';
        const indexFilePath = path.join(process.cwd(), 'index.js');
        const filePath = path.join(filesPath, fileTxt);

        const size = Utils.megabyteToByte(1);
        const type = 'txt';

        const forked = fork(indexFilePath, ['--fileName', filePath, '--size', size, '--type', type], {
            env: { DEBUG: 'fake-file-generator:*' }
        });

        await new Promise((resolve, reject) => {
            forked.on('close', resolve)
            forked.on('error', reject)
            forked.on('exit', code => {
                if (code !== 0) reject();
            })
        })

        const fileToCheckStats = await fsPromise.stat(filePath);
        assert.strictEqual(fileToCheckStats.size, size);
        const fileContent = await fsPromise.readFile(filePath);
        assert.strictEqual(fileContent.toString().includes(expectedEndFileContent), true);

    }, 100000)
    test('cli without filename required parameter', async () => {

        const indexFilePath = path.join(process.cwd(), 'index.js');

        const size = Utils.megabyteToByte(1);
        const type = 'txt';

        const forked = fork(indexFilePath, ['--size', size, '--type', type], {
            env: { DEBUG: 'fake-file-generator:*' }
        });

        await new Promise((resolve, reject) => {
            forked.on('close', resolve)
            forked.on('error', reject)
            forked.on('exit', code => {
                if (code === 1) {
                    resolve();
                } else {
                    reject();
                }
            })
        })

    }, 100000)
    test('cli without size required parameter', async () => {
        const indexFilePath = path.join(process.cwd(), 'index.js');
        const filePath = path.join(filesPath, fileTxt);

        const forked = fork(indexFilePath, ['--fileName', filePath], {
            env: { DEBUG: 'fake-file-generator:*' }
        });

        await new Promise((resolve, reject) => {
            forked.on('close', resolve)
            forked.on('error', reject)
            forked.on('exit', code => {
                if (code === 1) {
                    resolve();
                } else {
                    reject();
                }
            })
        })

    }, 100000)
})

describe('interactive mode', () => {
    test('generate not typed file', async () => {
        const indexFilePath = path.join(process.cwd(), 'index.js');
        const filePath = path.join(filesPath, fileNotTyped);

        const size = Utils.megabyteToByte(1);

        const forked = fork(indexFilePath, {
            env: { DEBUG: 'fake-file-generator:*' },
            stdio: 'pipe'
        });

        const promise = new Promise((resolve, reject) => {
            forked.on('error', reject)
            forked.on('exit', code => {
                if (code === 0) {
                    resolve();
                } else {
                    reject();
                }
            })
        })

        const expectedMessages = [
            'insert file name. Ex: sound.mp3',
            'insert size (bytes). Ex: 1000',
            'insert type (available: txt). press enter for default generic not typed file',
        ]

        let counterMessaged = 0;

        forked.stdout.on('data', (data) => {
            const dataString = data.toString().trim();

            // ignore empty console.log
            if (dataString === '') {
                return
            } else {
                counterMessaged++;
            }

            switch (counterMessaged) {
                case 1:
                    assert.strictEqual(dataString, expectedMessages[0]);
                    forked.stdin.write(filePath);
                    break;
                case 2:
                    assert.strictEqual(dataString, expectedMessages[1]);
                    forked.stdin.write(size.toString());
                    break;
                case 3:
                    assert.strictEqual(dataString, expectedMessages[2]);
                    forked.stdin.write('txt');
                    break;
            }
        })

        forked.stderr.on('data', (data) => {
            console.log('data', data.toString())
        })

        return promise;
    }, 100000)
})

// remove all files into autogenerated-files directory
beforeEach(async () => {
    const dirContent = await fsPromise.readdir(filesPath);
    if (!dirContent.length) {
        return;
    }
    const removeFilesPromises = dirContent.map((file) => {
        if (file === fileNotTyped || file === fileTxt) {
            const filePath = path.join(filesPath, file);
            return fsPromise.unlink(filePath);
        }
    })
    return Promise.all(removeFilesPromises);
});
